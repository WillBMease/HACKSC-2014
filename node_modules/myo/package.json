{
  "name": "myo",
  "version": "1.0.0",
  "description": "Javascript bindings for Myo",
  "main": "myo.js",
  "dependencies": {
    "ws": "^0.4.32"
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/stolksdorf/myo.js.git"
  },
  "keywords": [
    "myo",
    "thalmic",
    "myojs"
  ],
  "author": {
    "name": "stolksdorf"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/stolksdorf/myo.js/issues"
  },
  "homepage": "https://github.com/stolksdorf/myo.js",
  "readme": "**Note : ** If you are a bleeding-edge kind of developer, be sure to check out the [Experimental](https://github.com/stolksdorf/myo.js/tree/master/experimental) Myo.js features!\r\n\r\nLike node? We do too. `npm install myo` will do what you need. [Check it out!](https://www.npmjs.org/package/myo)\r\n\r\n# Myo.js\r\n\r\nMyo + Javascript?! Oh My!\r\n\r\n\r\n## Getting Started\r\n\r\nTo start you need two things : Your very own Myo, and [Myo Connect Software](https://developer.thalmic.com/downloads). This software will run on your computer, and talk with the Myo. From here you can manage your connected myos, load in Lua scripts, and test out the pose recognition.\r\n\r\nOnce those and installed and setup, you can just drop the Myo.js library into a webpage and start developing with Myo. Any user with Myo Connect running that visits your webpage/runs your app can user their Myo with your application.\r\n\r\nTry this out!\r\n\r\n\tvar myMyo = Myo.create();\r\n\tmyMyo.on('fingers_spread', function(edge){\r\n\t\tif(!edge) return;\r\n\t\talert('Hello Myo!');\r\n\t\tmyMyo.vibrate();\r\n\t});\r\n\r\n## Creating a Myo Instance\r\n\r\nThe Myo.js library can be access through the `Myo` variable. This is the core library and be used to create new Myo instances, trigger global events, amongst other things. To create a new Myo object use the `Myo.create()` function. This function can two parameters: an id (used for multi-Myo support), and specific options for that Myo.\r\n\r\n\tvar myMyo = Myo.create(); //Defaults to id 0\r\n\t//Make this Myo a bit more sensitive\r\n\tvar thirdMyo = Myo.create(2, {armbusy_threshold : 10});\r\n\r\nCommands and events used with these instances are specific to that Myo. You can create Myo instances for Myo that aren't connected yet. For example if your app uses an optional second Myo, create two instances, and listen for the `connected` event on the second one to enable dual Myo support.\r\n\r\n\r\n## Creating Listeners\r\n\r\nMyo.js is all about events. Whenever we receive data from the Myo, we'll filter through and emit contextual events. You create listeners to these events using the `myo.on()` function.\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\t//Edge is true if it's the start of the pose, false if it's the end of the pose\r\n\t\tif(edge){\r\n\t\t\tenemies.crush();\r\n\t\t}\r\n\t});\r\n\tmyMyo.on('gyroscope', function(data){\r\n\t\tif(data.x > 100){\r\n\t\t\talert('Woah now!')\r\n\t\t}\r\n\t});\r\n\r\n\r\n## Simple Actions\r\n\r\nHere are some techniques to get you started.\r\n\r\n### Holding Poses\r\n\r\nTo reduce the number of false positives, it's useful to react when the user holds a pose, rather than as soon as it's fired. We've provided a handy function, `myo.timer()` to make writing this as easy as possible. The function takes three parameters: A boolean to turn the timer off and on, a duration in milliseconds, and a function to run.\r\n\r\n\t//After holding thumb to pinky for 1/2 a second, the Myo will be unlocked for 2 seconds\r\n\tmyMyo.on('thumb_to_pinky', function(edge){\r\n\t\tmyMyo.timer(edge, 500, function(){\r\n\t\t\tmyMyo.unlock(2000);\r\n\t\t})\r\n\t});\r\n\r\n### Locking\r\n\r\nFor more passive apps, it's useful to \"lock\" and \"unlock\" the Myo so that accidental actions aren't picked up. We provide `.lock()` and `.unlock()` functions, `lock` and `unlock` events, and a `myo.isLocked` boolean. Myo.js doesn't implement any logic for locking and unlocking the Myo, that's up to you.\r\n\r\n\t//Thumb to pinky will unlock the Myo for 2 seconds\r\n\t// Wave out will make the menu go left, only if the Myo is unlocked,\r\n\t// also resets the relock for 5 seconds\r\n\t// The Myo will vibrate on lock and unlock.\r\n\tmyMyo.on('thumb_to_pinky', function(edge){\r\n\t\tmyMyo.unlock(2000);\r\n\t});\r\n\tmyMyo.on('wave_out', function(edge){\r\n\t\tif(edge && !myMyo.isLocked){\r\n\t\t\tmenu.left()\r\n\t\t\tmyMyo.unlock(5000);\r\n\t\t}\r\n\t});\r\n\tmyMyo.on('unlock', function(){\r\n\t\tmyMyo.vibrate();\r\n\t});\r\n\tmyMyo.on('lock', function(){\r\n\t\tmyMyo.vibrate('short').vibrate('short');\r\n\t});\r\n\r\n## Node support\r\n\r\nMyo.js also works on node! It uses the [ws](https://www.npmjs.org/package/ws) package for doing WebSockets. You have to do nothing extra, Myo.js will figure out if it's on a server or not and run accordingly. `npm install myo` will do what you need. [Check it out!](https://www.npmjs.org/package/myo)\r\n\r\n\r\n## Final Touches\r\n\r\nBefore you run off and built a Minority Report like interface, be sure to skim the reference below to see everything your Myo can do. If your itching for some assets and images to use you can grab our [branding](https://developer.thalmic.com/branding/) and [UX](https://developer.thalmic.com/ux/) guidelines here. Have fun!\r\n\r\n\r\n# Reference\r\n\r\n## Myo Core\r\n\r\n**options** &nbsp; `Myo.options` <br>\r\nHere you can review and set the default options that will be used for each Myo instance.\r\n\r\n**myos** &nbsp; `Myo.myos` <br>\r\nAn array containing the created Myo instances indexed by their id.\r\n\r\n**create** &nbsp; `Myo.create(), Myo.create(id), Myo.create(opts), Myo.create(id, opts)` <br>\r\nCreates and returns a new Myo instance. If no `id` is provided, defaults to 0. `opts` provided will overwrite the default options.\r\n\r\n\tvar myMyo = Myo.create();\r\n\tvar thirdMyo = Myo.create(2, {armbusy_threshold : 10});\r\n\r\n**on** &nbsp; `Myo.on(eventName, callback)` <br>\r\nCreates a global listener for each Myo instance for the given event. The `callback`'s context will be the Myo instance.\r\n\r\n\tMyo.on('connected', function(){\r\n\t\tconsole.log('connected!', this.id)\r\n\t});\r\n\r\n**start** &nbsp; `Myo.start()` <br>\r\nCreates web socket and sets up the message listener. Called on library load automatically.\r\n\r\n## Myo Instance\r\nA Myo instance is an individual Myo create using this library.\r\n\r\n### Data\r\n**id** &nbsp; `myo.id` <br>\r\nStores the id of the Myo.\r\n\r\n**connect_verion** &nbsp; `myo.connect_verion` <br>\r\nStores the version of Myo Connect.\r\n\r\n**direction** &nbsp; `myo.direction` <br>\r\nStores the direction that the User is wearing the Myo. Can either be `\"toward_elbow\"` or `\"toward_wrist\"`, referencing the Thalmic logo on the device.\r\n\r\n**arm** &nbsp; `myo.arm` <br>\r\nStores which arm the Myo is being worn on. Either `\"left\"` or `\"right\"`\r\n\r\n**orientationOffset** &nbsp; `myo.orientationOffset` <br>\r\nStores the offset quaternion used with `myo.zeroOrientation()`.\r\n\r\n**lastIMU** &nbsp; `myo.lastIMU` <br>\r\nStores the last IMU object. Useful when you need to look at changes over time.\r\n\r\n**isConnected** &nbsp; `myo.isConnected` <br>\r\nStores a boolean on whether the Myo is currently connected.\r\n\r\n**isLocked** &nbsp; `myo.isLocked` <br>\r\nStores a boolean on whether the Myo is currently locked.\r\n\r\n### Functions\r\n\r\n**on** &nbsp; `myo.on(eventName, function(arg1, arg2,...))` <br>\r\nOn sets up a listener for a specific event name. Whenever that event is triggered, each function added with `on()`, will be called with whatever arguments `trigger()` was called with. Returns a unique event id for this listener.\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\tif(edge)  console.log('fist pose start');\r\n\t\tif(!edge) console.log('fist pose end');\r\n\t});\r\n\r\n**trigger** &nbsp; `myo.trigger(eventName, arg1, arg2, ...)` <br>\r\nTrigger activates each listener for a specific event. You can add any additional parameters to be passed to the listener. Myo.js uses this internally to trigger events.\r\n\r\n\tmyMyo.on('foobar', function(msg){\r\n\t\tconsole.log('wooooo', msg)\r\n\t});\r\n\tmyMyo.trigger('foobar', 'ah yis!');\r\n\r\n\r\n**zeroOrientation** &nbsp; `myo.zeroOrientation()` <br>\r\nWhen called, where ever the Myo is orientated will now be the origin. This offset value will be stored at `myo.orientationOffset`.\r\n\r\n**lock** &nbsp; `myo.lock()` <br>\r\nSets `Myo.isLocked` to true and fires the `lock` event. Myo.js does nothing with `myo.isLocked`, it's up to the developer to implement locking features. For example:\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\tif(Myo.isLocked || !edge) return;\r\n\t\tEnemies.smash();\r\n\t});\r\n\r\n**unlock** &nbsp; `myo.unlock(), Myo.unlock(timeout)` <br>\r\nSets `Myo.isLocked` to false and fires the `unlock` event. If a `timeout` is passed in, it will call `myo.lock()` after the timeout has passed. Subsequient calls will reset the timeout.\r\n\r\n\tmyMyo.unlock(); //Will unlock the Myo indefinitely\r\n\tmyMyo.unlock(1000); //Unlocks the Myo, but will relock after 1 second\r\n\r\n**vibrate** &nbsp; `myo.vibrate(), myo.vibrate('short' | 'medium' | 'long')` <br>\r\nMakes the Myo vibrate with a given duration. Defaults to `'medium'`.\r\n\r\n**requestBluetoothStrength** &nbsp; `myo.requestBluetoothStrength()` <br>\r\nRequests the connection strength of the Myo to be sent. Listen to the `'bluetooth_strength'` event for the data.\r\n\r\n\tmyMyo.on('bluetooth_strength', function(val){\r\n\t\tconsole.log('Such strength', val);\r\n\t});\r\n\tmyMyo.requestBluetoothStrength();\r\n\r\n**timer** &nbsp; `myo.timer(on_off, duration, callback)` <br>\r\nTimer is useful for when you want a simple timeout for an action, such as holding a gesture for a period of time. `on_off` is a boolean that will create or disable the current timer with a duration of `duration` that will fire the `callback`.\r\n\r\n\t//Fires a spread_hold event if spread is held for half a second\r\n\tmyMyo.on('fingers_spread', function(edge){\r\n\t\tmyMyo.timer(edge, 500, function(){\r\n\t\t\tmyMyo.trigger('spread_hold')\r\n\t\t})\r\n\t})\r\n\r\n\r\n\r\n## Events\r\nYou can create listeners to the events by using the `myo.on()` function. You can even fire your own events using `myo.trigger()`.\r\n\r\n**connected** &nbsp; `myo.on('connected', function(){ ... })` <br>\r\nFired when the Myo is successfully connected with the Myo Connect software. Populates `myo.connect_version`.\r\n\r\n**disconnected** &nbsp; `myo.on('disconnected', function(){ ... })` <br>\r\nFired when the Myo is disconnected from the Myo Connect software.\r\n\r\n**arm_recognized** &nbsp; `myo.on('arm_recognized', function(){ ... })` <br>\r\nFired when the User puts on the Myo and successfully does the Setup Gesture. Populates `myo.arm` and `myo.direction`\r\n\r\n**arm_lost** &nbsp; `myo.on('arm_lost', function(){ ... })` <br>\r\nFired when the User removes the Myo.\r\n\r\n**imu** &nbsp; `myo.on('imu', function(data){ ... })` <br>\r\nThis event is fired whenever we receive IMU data from the Myo. This data is grouped like this:\r\n\r\n\t{\r\n\t\torientation : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM,\r\n\t\t\tW : NUM\r\n\t\t},\r\n\t\tgyroscope : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM\r\n\t\t},\r\n\t\taccelerometer : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM\r\n\t\t}\r\n\t}\r\n\r\n**gyroscope** &nbsp; `myo.on('gyroscope', function(data){ ... })` <br>\r\nThis event is fired whenever we receive gyroscopic data from the Myo. This data is grouped as 3d coordinates.\r\n\r\n**orientation** &nbsp; `myo.on('orientation', function(data){ ... })` <br>\r\nThis event is fired whenever we receive orientation data from the Myo. This data is grouped as a quanternion.\r\n\r\n**accelerometer** &nbsp; `myo.on('accelerometer', function(data){ ... })` <br>\r\nThis event is fired whenever we receive acceleration data from the Myo. This data is grouped as 3d coordinates.\r\n\r\n**bluetooth_strength** &nbsp; `myo.on('bluetooth_strength', function(data){ ... })` <br>\r\nFired after `Myo.requestBluetoothStrength()` is called. Returns a measure of the bluetooth strength the Myo is connected to.\r\n\r\n**pose** &nbsp; `myo.on('pose', function(pose_name, edge){ ... })` <br>\r\nWhenever the Myo detects a pose change it will fire a `pose` event. The listener will be called with the `pose_name` and the `edge` which will be `true` if it is the start of the pose and `false` if it is the end of the pose. Myo.js will also fire an individual event for each pose with the `edge` as the only parameter for the listener. Here is a list of all the poses : `rest`,`fingers_spread`,`wave_in`,`wave_out`,`fist`,`thumb_to_pinky`.\r\n\r\n\tMyo.on('pose', function(pose_name, edge){\r\n\t\tif(pose_name != 'rest' && edge){\r\n\t\t\tconsole.log('Started ', pose_name);\r\n\t\t}\r\n\t});\r\n\tvar myMyo = Myo.create();\r\n\tmyMyo.on('wave_in', function(edge){\r\n\t\tif(edge) Menu.left()\r\n\t})\r\n\r\n**lock** &nbsp; `myo.on('lock', function(){ ... })` <br>\r\nFired whenever `myo.lock()` is called. Useful for firing vibration events, or updating UI when the Myo becomes locked.\r\n\r\n**unlock** &nbsp; `myo.on('unlock', function(){ ... })` <br>\r\nFired whenever `myo.unlock()` is called. Useful for firing vibration events, or updating UI when the Myo becomes unlocked.\r\n\r\n\r\n# TODO\r\n\r\n* Make the diagnostics page prettier\r\n* Roll this into an NPM module for nooooooooooode\r\n* Add a few more demos",
  "readmeFilename": "README.md",
  "_id": "myo@1.0.0",
  "_shasum": "005fd79c485947fbc0dd4264e50ce461377182cf",
  "_from": "myo@",
  "_resolved": "https://registry.npmjs.org/myo/-/myo-1.0.0.tgz"
}
