{
  "name": "my",
  "version": "0.3.3",
  "description": "my JavaScript module system",
  "keywords": [
    "module",
    "loader",
    "import",
    "export"
  ],
  "author": {
    "name": "Hax",
    "email": "johnhax@gmail.com",
    "url": "http://johnhax.net/"
  },
  "homepage": "http://github.com/hax/my.js",
  "bugs": "http://github.com/hax/my.js/issues",
  "main": "my.js",
  "bin": {
    "mym": "./cli.js"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/hax/my.js.git"
  },
  "readme": "# my.js #\r\n\r\n\r\n### What is my.js ###\r\n\r\nThis project 'my.js' want to be the ultimate JavaScript module solution\r\nfor everyone. It's based on my thought about module ecosystem from long\r\nlong ago to recent.\r\n\r\nIt's still in alpha phase, but I am working hard and a stable version\r\nwill be available soon.\r\n\r\n\r\n#### Implemented features ####\r\n\r\n* ES6-like module/imports/exports declarations\r\n* Core loader for Node.js\r\n* Core loader for browsers (IE 6+)\r\n\r\n#### Features in near future ####\r\n\r\n* support CommonJS 1.0\r\n* support CMD\r\n\r\n\r\n### Basic Ideas/Requirements ###\r\n\r\n* Let all js be my js\r\n\r\n\t- whatever module spec it follows (CommonJS, AMD, CMD, etc.)\r\n\t- whatever module system it adpoted (RequireJS, SeaJS, JSI, etc.)\r\n\t- whatever script loader it accustomed to (LabJS, JSAN, Google JSAPI ...)\r\n\t- whatever module pattern it used (function wrapper, eg. jQuery ...)\r\n\t- and even for the old module-less script tag\r\n\r\n* Future proof\r\n\r\n\t- based on ES6 module semantics, forward compatible with ES6\r\n\t- support module/imports/exports declarations in ES6-like syntax for ES3-5\r\n\t- auto translate require() to ES6-like imports,\r\n\t  since require() is buzzy and lose the benifits of static bindings\r\n\t- auto analyze exports for wrapped or even naked script,\r\n\t  aka. module-less scripts traditionally loaded by script tag\r\n\t- allow manually define modules if auto translating/analysis is not enough\r\n\t  accurate or not possible at all\r\n\r\n* Easy to read, write and maintain the module definitions\r\n\r\n\t- define modules with a DSL which use a designed ES3 syntax subset\r\n\t- support both centrelized and distributed module definitions\r\n\t- support both local files/directories and Web URLs\r\n\t- can build buddled packages for different enviroments\r\n\t\t(eg. can generate diff deployment files for diff browsers)\r\n\t- minify the diffs of dev/product via resource mapping rules\r\n\t- limited module version support (to avoid bad practice)\r\n\r\n* Server-solution friendly\r\n\r\n\t- cross-origin proxy\r\n\t- scripts merge and minifier\r\n\t- AMD/CMD wrapper\r\n\t- alternative URLs from cdn\r\n\r\n* Add-ons\r\n\r\n\t- Allow to add code translators such as wrapper, preprocessor, compiler, etc.\r\n\t- Example:\r\n\t\tmodule directive addon allow import/export/module/submodule directives in diff styles\r\n\t\tcoffeescript addon to support coffeescript\r\n\r\n\r\n### Usage ###\r\n\r\n* Browser:\r\n\r\n```html\r\n<head>\r\n\t...\r\n\t<script src=\"http://hax.github.com/my.js\" load=\"app.js\">\r\n\t...\r\n</head>\r\n```\r\n\r\n**NOTE:**\r\n\tBrowser feature is unfinished, currently you should use\r\n\t```<script src=\"./dist/my.browser.js\">```\r\n\tfor standard browsers (IE 9+), or\r\n\t```<script src=\"./dist/my.browser.legacy.js\">```\r\n\tfor legacy browsers (IE 6, 7, 8)\r\n\r\n\r\n* Node.js or CommonJS\r\n\r\n```javascript\r\nrequire('my').load('app')\r\n```\r\n\r\n\r\n### Declare module, imports and exports in ES6-like syntax ###\r\n\r\nThough my.js try to support all popular loaders and module systems, I recommand\r\nyou start moving to my.js built-in ES6-like module system, because it is\r\nforward compatible with ES6 and can be auto migrate to ES6 with no pain.\r\nCurrently my.js support two styles of declarations in-box,\r\ndirective prologues (just like 'use strict'), and labeled module statements\r\n(inspired by <https://github.com/labeledmodules/labeled-modules-spec/wiki>)\r\n\r\n**NOTE:\r\n\tCurrently (v0.3.3), only labeled module statements is implemented!\r\n\tDirective prologues will be added in next version!**\r\n\r\n```javascript\r\n// math.js (directive prologues)\r\n\r\n'export {sum, pi}'\r\n\r\nfunction sum(x, y) {\r\n\treturn x + y\r\n}\r\nvar pi = 3.14159265\r\n```\r\n```javascript\r\n// math.js (labeled module statements)\r\n\r\nexports: function sum(x, y) {\r\n\treturn x + y\r\n}\r\nexports: var pi = 3.14159265\r\n```\r\n```javascript\r\n// simple client code (directive prologues)\r\n\r\n'import {sum, pi} from \"math.js\"'\r\n\r\nalert(\"2π = \" + sum(pi, pi))\r\n```\r\n```javascript\r\n// simple client code (labeled module statements)\r\n\r\nimports: {sum; pi} from: 'math.js'\r\n\r\nalert(\"2π = \" + sum(pi, pi))\r\n```\r\n\r\nCheat sheet:\r\n```\r\nES6 module statements        my.js directive prologues        my.js labeled module statements\r\n                             * prologues only can occur at    * suffix 's' to avoid reserved keywords\r\n                               the beginning of a file        * use ';' instead of ','\r\n```\r\n```javascript\r\nimport {a, b} from \"m.js\"    'import {a, b} from \"m.js\"'      imports: {a; b} from: \"m.js\"\r\n```\r\n```javascript\r\nimport {a:a1} from \"m1.js\"    'import {a:a1} from \"m1.js\"'    imports: {a:a1} from: \"m1.js\"\r\nimport {a:a2} from \"m2.js\"    'import {a:a2} from \"m2.js\"'    imports: {a:a2} from: \"m2.js\"\r\n```\r\n```javascript\r\nexport function f() {...}    'export f'                       exports: function f() {....}\r\n                             ...\r\n                             function f() {...}\r\n```\r\n```javascript\r\nexport var v                 'export v'                       exports: var v\r\n                             ...\r\n                             var v\r\n```\r\n```javascript\r\nvar a, b                     'export {a, b}'                  var a, b\r\n...                          ...                              ...\r\nexport {a, b}                var a, b                         exports: {a; b}\r\n```\r\n```javascript\r\nvar _a, _b                   'export {a: _a, b: _b}'          var _a, _b\r\n...                          ...                              ...\r\nexport {a: _a, b: _b}        var _a, _b                       exports: {a: _a; b: _b}\r\n```\r\n\r\n\r\n### DSL ###\r\n\r\n**Not implemented yet!**\r\n\r\n```javascript\r\n// define the module _traits_ from local file\r\nmodule ('traits'). at ('traits.js/lib/traits.js')\r\n\r\n// define the module _light_traits_ which follow AMD spec\r\nmodule ('light_traits'). at [AMD] ('traits.js/lib/traits.js')\r\n\r\n// define the module _qwrap_ as naked script and exports the name _QW_\r\nmodule ('qwrap'). at [SCRIPT] ('core_dom_youa.com.js#QW')\r\n\r\n// define the module from the web\r\nmodule ('gloader'). at [SCRIPT] ('https://www.google.com/jsapi#google')\r\n\r\n// define the module from data uri\r\n// NOTE: it makes building deployment version possible and easy,\r\n//       all we need to do is resource mapping\r\nmodule ('sample1'). at ('data:application/javascript,exports.Greeting = {hello:\"world\"}')\r\n\r\n// define another module which use last module\r\nmodule ('sample2'). at ('http://www.example.org/sample2.js')\r\n\r\n// define a cross-origin proxy, so all http requests will be routed to the proxy\r\nresource ('http://*'). from ('/proxy?url=$1')\r\n\r\n// so _sample2_ will be transformed, and just like u write:\r\nmodule ('sample2'). at ('/proxy?url=http://www.example.org/sample2.js')\r\n// NOTE: url encode is missed here for easy to understand, but in real impl\r\n//       it should be for encoded each mapping step\r\n\r\n// This will be transformed internally to AMD wrapper form just like u write:\r\nmodule ('sample2'). at [AMD] ('amdwrap:/proxy?url=http://www.example.org/sample2.js')\r\n\r\n// Normally, the _amdwrap_ derefernce will be called to wrap code dynamically,\r\n// but you can define a server-generated AMD wrapper\r\nresource ('amdwrap:*'). from ('/amdwrap?url=$1')\r\n\r\n// So, it will transform the _sample2_ to:\r\nmodule ('sample2'). at [AMD] ('/amdwrap?url=/proxy?url=http://www.example.org/sample2.js')\r\n// NOTE: url encode is missed here for easy to understand, but in real impl\r\n//       it should be for encoded each mapping step\r\n\r\n\r\n// define a resouce mapping rule, so last module will load source from data URI!\r\nresource ('http://www.example.org/sample2.js'). from (\r\n\t\"data:,var G = require('sample1').Greeting; console.info(G.hello);\"\r\n)\r\n\r\n// define another module from legacy scripts\r\nmodule ('sample3').\r\n\timports ('Global.console').\r\n\timports ('Greeting'). // which will be resolve to last _smaple1_ module\r\n\tinclude ('sample/legacy.js'). // content: console.info('Hello' + Greeting.hello)\r\nend\r\n\r\n// define a module delegate to directory, so the modules definitions can be distributed\r\nmodule ('geo'). at ('geo/*')\r\n```\r\n\r\n\r\n### Rational ###\r\n\r\n// TODO\r\n\r\n\r\n### PS. ###\r\n\r\nQ:\tDoes the name 'my.js' have any other meaning?\r\n\r\nA:\tYes, there are many abbrev options, choose what you like,\r\n\tor you can suggest one.\r\n\r\n\t* Module Yes!\r\n\r\n\t* Make happY JavaScript!\r\n\r\n\t* Module Yoga for JavaScript  --- make your body flexible\r\n\r\n\t* Module Yammy!  --- take what match your taste\r\n\r\n\t* Module Yamiedie...\r\n\r\n\r\n",
  "_id": "my@0.3.3",
  "dist": {
    "shasum": "8b13ee137fd67a005176235b964a445c8ea60f4e",
    "tarball": "http://registry.npmjs.org/my/-/my-0.3.3.tgz"
  },
  "_npmVersion": "1.1.59",
  "_npmUser": {
    "name": "hax",
    "email": "hax@heshijun.net"
  },
  "maintainers": [
    {
      "name": "hax",
      "email": "hax@heshijun.net"
    }
  ],
  "directories": {},
  "_shasum": "8b13ee137fd67a005176235b964a445c8ea60f4e",
  "_from": "my@",
  "_resolved": "https://registry.npmjs.org/my/-/my-0.3.3.tgz"
}
